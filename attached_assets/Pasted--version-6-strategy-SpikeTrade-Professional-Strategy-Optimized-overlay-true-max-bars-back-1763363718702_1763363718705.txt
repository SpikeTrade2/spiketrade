//@version=6
strategy('SpikeTrade Professional Strategy - Optimized', overlay = true, max_bars_back = 5000, max_lines_count = 500, max_labels_count = 500, pyramiding = 0, calc_on_every_tick = false, commission_type = strategy.commission.percent, commission_value = 0.1)

// === INPUTS ===
// Spike Detection Thresholds
spike_group = 'Spike Detection Thresholds'
spike_price_z = input.float(4.0, 'Price ROC Z-Score Threshold', minval = 0.5, maxval = 6.0, step = 0.1, group = spike_group)
spike_rsi_z = input.float(5.0, 'RSI ROC Z-Score Threshold', minval = 0.5, maxval = 6.0, step = 0.1, group = spike_group)
spike_obv_z = input.float(5.0, 'OBV ROC Z-Score Threshold', minval = 0.5, maxval = 6.0, step = 0.1, group = spike_group)
spike_mfi_z = input.float(5.0, 'MFI ROC Z-Score Threshold', minval = 0.5, maxval = 6.0, step = 0.1, group = spike_group)
spike_bb_z = input.float(5.0, 'Bollinger %B ROC Z-Score Threshold', minval = 0.5, maxval = 6.0, step = 0.1, group = spike_group)
spike_vwap_z = input.float(5.0, 'VWAP ROC Z-Score Threshold', minval = 0.5, maxval = 6.0, step = 0.1, group = spike_group)
spike_volume_z = input.float(6.0, 'Volume ROC Z-Score Threshold', minval = 0.5, maxval = 6.0, step = 0.1, group = spike_group)

// ROC Thresholds
roc_thresh_group = 'ROC Thresholds (%)'
price_roc_thresh = input.float(0.3, 'Price ROC Threshold', group = roc_thresh_group)
rsi_roc_thresh = input.float(1.2, 'RSI ROC Threshold', group = roc_thresh_group)
obv_roc_thresh = input.float(2.4, 'OBV ROC Threshold', group = roc_thresh_group)
mfi_roc_thresh = input.float(2.4, 'MFI ROC Threshold', group = roc_thresh_group)
bb_roc_thresh = input.float(1.2, 'Bollinger %B ROC Threshold', group = roc_thresh_group)
vwap_roc_thresh = input.float(0.6, 'VWAP ROC Threshold', group = roc_thresh_group)
volume_roc_thresh = input.float(6.0, 'Volume ROC Threshold', group = roc_thresh_group)

// Periods
period_group = 'Indicator Periods'
price_roc_period = input.int(12, 'Price ROC Period', group = period_group)
rsi_roc_period = input.int(4, 'RSI ROC Period', group = period_group)
obv_roc_period = input.int(12, 'OBV ROC Period', group = period_group)
mfi_roc_period = input.int(6, 'MFI ROC Period', group = period_group)
bb_roc_period = input.int(6, 'Bollinger %B ROC Period', group = period_group)
vwap_roc_period = input.int(12, 'VWAP ROC Period', group = period_group)
volume_roc_period = input.int(12, 'Volume ROC Period', group = period_group)

// Risk Management
risk_group = 'Risk Management'
stop_loss_pct = input.float(3.0, 'Stop Loss %', minval = 0.5, maxval = 12.0, step = 0.1, group = risk_group)
target_gain_pct = input.float(2.4, 'Target Gain %', minval = 0.5, maxval = 12.0, step = 0.1, group = risk_group)
use_atr_stops = input.bool(true, 'Use ATR-Based Stops (3x ATR)', group = risk_group)

// Indicator Parameters
indicator_params_group = 'Indicator Parameters'
rsi_length = input.int(30, 'RSI Length', group = indicator_params_group)
bb_length = input.int(14, 'Bollinger Bands Length', group = indicator_params_group)
bb_mult = input.float(2.2, 'Bollinger Bands Std Dev', group = indicator_params_group)
mfi_length = input.int(12, 'MFI Length', group = indicator_params_group)
atr_length = input.int(16, 'ATR Length', group = indicator_params_group)

// Prediction Line Settings
pred_group = 'Prediction Line Settings'
pred_frequency_min = input.int(45, 'Prediction Frequency (Minutes)', minval = 1, group = pred_group)
pred_length_min = input.int(45, 'Prediction Horizon (Minutes)', minval = 1, group = pred_group)
pred_lookback_days = input.int(3, 'Historical Lookback (Days)', minval = 1, group = pred_group) // Default changed to 3 for safety
pred_sensitivity = input.float(1.0, 'Prediction Sensitivity', minval = 0.1, maxval = 5.0, step = 0.1, group = pred_group)
max_pred_lines = input.int(100, 'Max Prediction Lines', minval = 1, group = pred_group)

// === HELPER FUNCTIONS ===
calc_roc(src, period) =>
    src_prev = src[period]
    math.abs(src_prev) > 0.0001 ? (src - src_prev) / math.abs(src_prev) * 100 : 0.0

calc_z_score(src, period) =>
    roc_series = calc_roc(src, 1)
    mean = ta.sma(roc_series, period)
    stdev = ta.stdev(roc_series, period)
    stdev != 0 ? (roc_series - mean) / stdev : 0.0

// === INDICATOR CALCULATIONS ===
rsi = ta.rsi(close, rsi_length)
[bb_middle, bb_upper, bb_lower] = ta.bb(close, bb_length, bb_mult)
percent_b = bb_upper != bb_lower ? (close - bb_lower) / (bb_upper - bb_lower) : 0.5
mfi = ta.mfi(close, mfi_length)
obv = ta.cum(close > close[1] ? volume : close < close[1] ? -volume : 0)
atr = ta.atr(atr_length)
vwap_val = ta.vwap(hlc3)

min_period = math.max(price_roc_period, rsi_roc_period, obv_roc_period, mfi_roc_period, bb_roc_period, vwap_roc_period, volume_roc_period)

// === ROC & Z-Score CALCULATIONS ===
is_data_ready = bar_index >= min_period
price_roc = is_data_ready ? calc_roc(close, price_roc_period) : na
rsi_roc = is_data_ready ? calc_roc(rsi, rsi_roc_period) : na
obv_roc = is_data_ready ? calc_roc(obv, obv_roc_period) : na
mfi_roc = is_data_ready ? calc_roc(mfi, mfi_roc_period) : na
bb_roc = is_data_ready ? calc_roc(percent_b, bb_roc_period) : na
vwap_roc = is_data_ready ? calc_roc(vwap_val, vwap_roc_period) : na
volume_roc = is_data_ready ? calc_roc(volume, volume_roc_period) : na

price_z = is_data_ready ? calc_z_score(close, price_roc_period) : na
rsi_z = is_data_ready ? calc_z_score(rsi, rsi_roc_period) : na
obv_z = is_data_ready ? calc_z_score(obv, obv_roc_period) : na
mfi_z = is_data_ready ? calc_z_score(mfi, mfi_roc_period) : na
bb_z = is_data_ready ? calc_z_score(percent_b, bb_roc_period) : na
vwap_z = is_data_ready ? calc_z_score(vwap_val, vwap_roc_period) : na
volume_z = is_data_ready ? calc_z_score(volume, volume_roc_period) : na

// === STRATEGY LOGIC ===
any_spike = is_data_ready and (nz(price_z) > spike_price_z or nz(rsi_z) > spike_rsi_z or nz(obv_z) > spike_obv_z or nz(mfi_z) > spike_mfi_z or nz(bb_z) > spike_bb_z or nz(vwap_z) > spike_vwap_z or nz(volume_z) > spike_volume_z)

// Antithesis logic: detect opposite conditions
opposite_conditions = is_data_ready and (nz(price_z) < -spike_price_z * 0.2 or nz(rsi_z) < -spike_rsi_z * 0.2 or nz(obv_z) < -spike_obv_z * 0.2 or nz(mfi_z) < -spike_mfi_z * 0.2 or nz(bb_z) < -spike_bb_z * 0.2 or nz(vwap_z) < -spike_vwap_z * 0.2 or nz(volume_z) < -spike_volume_z * 0.2)

sell_condition = opposite_conditions and strategy.position_size > 0

if sell_condition
    strategy.close('BUY')
// Trend Filter
trend_filter = ta.sma(close, 50) > ta.sma(close, 200)
// Buy condition
c_price = not na(price_roc) and price_roc > price_roc_thresh * 0.5 ? 1 : 0
c_rsi = not na(rsi_roc) and rsi_roc > rsi_roc_thresh * 0.5 ? 1 : 0
c_obv = not na(obv_roc) and obv_roc > obv_roc_thresh * 0.5 ? 1 : 0
c_mfi = not na(mfi_roc) and mfi_roc > mfi_roc_thresh * 0.5 ? 1 : 0
c_bb = not na(bb_roc) and bb_roc > bb_roc_thresh * 0.5 ? 1 : 0
c_vwap = not na(vwap_roc) and vwap_roc > vwap_roc_thresh * 0.5 ? 1 : 0
c_vol = not na(volume_roc) and volume_roc > volume_roc_thresh * 0.5 ? 1 : 0

conditions_met = c_price + c_rsi + c_obv + c_mfi + c_bb + c_vwap + c_vol
signal_probability = conditions_met / 7 * 100

buy_condition = any_spike and conditions_met >= 2 and trend_filter

atr_stop = close - atr * 3.0
stop_level = use_atr_stops ? atr_stop : close * (1 - stop_loss_pct / 100)
target_level = close * (1 + target_gain_pct / 100)

if buy_condition and strategy.position_size == 0
    strategy.entry('BUY', strategy.long)
strategy.exit('EXIT', 'BUY', stop = stop_level, limit = target_level)

// === PLOTS ===
plot(ta.ema(close, 9), color = color.new(color.green, 0), title = 'EMA 9')
plot(ta.ema(close, 20), color = color.new(color.orange, 0), title = 'EMA 20')
plot(ta.ema(close, 50), color = color.new(color.red, 0), title = 'EMA 50')
bgcolor(signal_probability > 70 ? color.new(color.red, 85) : na)

// === PREDICTION LINE LOGIC (ENHANCED VISIBILITY V2) ===

// 1. DEFINE A CUSTOM TYPE to store both the line ID and its original color.
type PredictionLine
	line id
	color initialColor

// 2. CHANGE THE ARRAY to store our new custom 'PredictionLine' objects.
var array<PredictionLine> predLines = array.new<PredictionLine>()

// --- Timeframe Calculations ---
minutes_per_bar = timeframe.multiplier * (timeframe.isseconds ? 1.0 / 60.0 : timeframe.isminutes ? 1.0 : timeframe.isdaily ? 1440.0 : timeframe.isweekly ? 10080.0 : 43800.0)

bars_in_day = minutes_per_bar > 0 ? 1440.0 / minutes_per_bar : 0
pred_lookback_bars = int(pred_lookback_days * bars_in_day)

pred_frequency_bars = minutes_per_bar > 0 ? math.max(1, int(pred_frequency_min / minutes_per_bar)) : 1
pred_length_bars = minutes_per_bar > 0 ? math.max(1, int(pred_length_min / minutes_per_bar)) : 1

// --- Main Calculation & Drawing Logic ---
bool is_trigger_bar = bar_index > pred_lookback_bars and pred_frequency_bars > 0 and bar_index % pred_frequency_bars == 0

if is_trigger_bar
    // --- VISUAL ENHANCEMENT: FADE OLD LINES ---
    if array.size(predLines) > 0
        for i = 0 to array.size(predLines) - 1 by 1
            // 3. Get the whole object from the array.
            lineObject = array.get(predLines, i)
            line_id = lineObject.id
            original_color = lineObject.initialColor // <-- The fix: We retrieve the color we saved earlier.

            // Now we can create the faded color and apply the style changes.
            faded_color = color.new(original_color, 85)
            line.set_color(line_id, faded_color)
            line.set_width(line_id, 1)
            line.set_style(line_id, line.style_dotted)

    // --- Calculate the New Prediction ---
    composite_indicator = (nz(price_z) + nz(rsi_z) + nz(obv_z) + nz(mfi_z) + nz(bb_z) + nz(vwap_z) + nz(volume_z)) / 7.0
    y2 = ta.linreg(composite_indicator, pred_lookback_bars, 0)
    y1 = ta.linreg(composite_indicator, pred_lookback_bars, 1)
    slope = y2 - y1
    projected_price_change = slope * pred_length_bars * atr * pred_sensitivity
    projected_price = close + projected_price_change

    // 4. DETERMINE the new line's color before creating it.
    new_line_color = slope > 0 ? color.new(color.green, 30) : color.new(color.red, 30)

    // --- Draw the new, PROMINENT line ---
    new_line_id = line.new(x1 = bar_index, y1 = close, x2 = bar_index + pred_length_bars, y2 = projected_price, color = new_line_color, width = 2, extend = extend.right, style = line.style_arrow_right)

    // 5. CREATE AND STORE the new custom object in our array.
    array.push(predLines, PredictionLine.new(new_line_id, new_line_color))

    // --- Manage Memory ---
    if array.size(predLines) > max_pred_lines
        // Get the oldest object from the start of the array
        oldestLineObject = array.shift(predLines)
        // Delete the line associated with that object
        line.delete(oldestLineObject.id)